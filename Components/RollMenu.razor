@rendermode InteractiveServer
@inject RollService RollService
<!-- Middle -->

<Counter Title="Advantage" Id="Advantage" @bind-CounterValue="Advantage" @bind-CounterValue:after="UpdateAdvantage" />


<div class="flex-grow-1 m-auto">
  <div class="text-center m-auto h-100">

    <h2 class="">@RollText: @LastResult?.Result   </h2>
    <ul>
      @if(LastResult != null) {
        @foreach(IndividualRollResult roll in LastResult?.Rolls) {
          <li>@(roll.Expression): @roll.Result</li>
        
        }
      }

    </ul>
  </div>
</div>

@if(Character != null) {

  <div class="m-1 d-flex flex-wrap gap-2">
      @foreach (var stat in Character?.SpecialStats)
      {
          <button class="btn flex-fill @btnClasses[stat.Name]" @onclick="() => AddStat(stat.Name)">
              + @stat.Name
          </button>
      }
  </div>
  <div class="m-1 d-flex flex-wrap gap-2">
      @foreach (var stat in Character?.Stats)
      {
          <button class="btn flex-fill @btnClasses[stat.Name]" @onclick="() => AddStat(stat.Name)">
              + @Truncate(stat.Name)
          </button>
      }
  </div>
}

<div class="m-1 d-flex gap-2 flex-grow-2 bg-light text-black">
  <input class="form-control fs-5" @bind="@RollText" />
</div>

<div class="m-1 d-flex gap-2 flex-grow-2">
  <button class="btn btn-secondary fs-3 flex-grow-1" @onclick="ClearRoll">
    Clear
  </button>
  <button @onclick="Roll" class="btn btn-primary fs-3 flex-grow-1">Roll</button>
</div>

@code {

    async Task Roll() {

      var response = await RollService.RollFor(Character,RollText);    

      LastResult = response;
    }

    public RollResult? LastResult {get; set;}

    [Parameter]
    public PlayerCharacter? Character { get; set; }

    public int Advantage { get; set; }

    public IEnumerable<Stat> Stats { get; set; }

    [Parameter]
    public bool? FlexFill { get; set; }

    private string RollText;

    Dictionary<string, string> btnClasses = new();

    protected override void OnInitialized() {
        ClearRoll();

    }

    private string Truncate(string input, int length = 3)
    {
        return input.Substring(0, Math.Min(length, input.Length));
    }

    void UpdateAdvantage() {
        SetAdvantage(Advantage);
    }

    private void AddStat(string statName)
    {
        var strToReplace = $"+{statName.ToLower()}";
    
        if(RollText.Contains(strToReplace)) {
            RollText = RollText.Replace(strToReplace,"");
            btnClasses[statName] = "btn-secondary";
        }
        else {
            RollText += strToReplace;
            btnClasses[statName] = "btn-primary";
        }
    }

    private void ClearRoll()
    {
        RollText = Character?.DefaultRoll ?? "1d100";
        LastResult = null;
        Advantage = 0;
        if(Character != null ) {
          foreach (var stat in Character?.Stats)
              btnClasses[stat.Name] = "btn-secondary";

          foreach (var stat in Character?.SpecialStats)
            btnClasses[stat.Name] = "btn-secondary";
        }
    }

    private void SetAdvantage(int adv)
    {
        var patternMax = new System.Text.RegularExpressions.Regex(@"max\(([^)]+)\)");
        var patternMin = new System.Text.RegularExpressions.Regex(@"min\(([^)]+)\)");
        var pattern1d = new System.Text.RegularExpressions.Regex(@"\b1d(\d+)\b");

        // Find first group: max, min, or 1dX
        if (patternMax.IsMatch(RollText))
        {
            RollText = patternMax.Replace(RollText, m =>
            {
                var inside = m.Groups[1].Value;
                var parts = inside.Split(',');
                if (parts.Length == 0) return m.Value;

                var dice = parts[0].Trim();

                if (adv > 0)
                {
                    var count = adv + 1;
                    var newParts = new List<string>();
                    for (int i = 0; i < count; i++)
                        newParts.Add(dice);
                    return $"max({string.Join(",", newParts)})";
                }
                else if (adv == 0)
                {
                    return dice;
                }
                else // adv < 0
                {
                    var count = Math.Abs(adv) + 1;
                    if (count == 1) return dice;
                    var newParts = new List<string>();
                    for (int i = 0; i < count; i++)
                        newParts.Add(dice);
                    return $"min({string.Join(",", newParts)})";
                }
            }, 1);
        }
        else if (patternMin.IsMatch(RollText))
        {
            RollText = patternMin.Replace(RollText, m =>
            {
                var inside = m.Groups[1].Value;
                var parts = inside.Split(',');
                if (parts.Length == 0) return m.Value;

                var dice = parts[0].Trim();

                if (adv < 0)
                {
                    var count = Math.Abs(adv) + 1;
                    var newParts = new List<string>();
                    for (int i = 0; i < count; i++)
                        newParts.Add(dice);
                    return $"min({string.Join(",", newParts)})";
                }
                else if (adv == 0)
                {
                    return dice;
                }
                else // adv > 0
                {
                    var count = adv + 1;
                    var newParts = new List<string>();
                    for (int i = 0; i < count; i++)
                        newParts.Add(dice);
                    return $"max({string.Join(",", newParts)})";
                }
            }, 1);
        }
        else if (pattern1d.IsMatch(RollText))
        {
            RollText = pattern1d.Replace(RollText, m =>
            {
                var dice = m.Value;

                if (adv == 0)
                    return dice;

                var count = Math.Abs(adv) + 1;
                var fn = adv > 0 ? "max" : "min";

                var newParts = new List<string>();
                for (int i = 0; i < count; i++)
                    newParts.Add(dice);

                return $"{fn}({string.Join(",", newParts)})";
            }, 1);
        }
    }
}
